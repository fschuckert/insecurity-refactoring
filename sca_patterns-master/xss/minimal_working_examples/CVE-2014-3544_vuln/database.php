<?php

define('SQL_PARAMS_NAMED', 1);
define('IGNORE_MISSING', 0);
define('IGNORE_MULTIPLE', 1);

abstract class Database
{
    protected $pdo;

    function __construct()
    {
        $this->pdo = new PDO('sqlite:test.sql', null, null, array(PDO::ATTR_PERSISTENT => true));
        $this->pdo->query("CREATE TABLE user (id int, skypeid varchar(255));");
    }

    function insert($id, $skypeid)
    {
        $stmt = $this->pdo->prepare("INSERT INTO user VALUES (:id, :skypeid)");
        $stmt->execute(array(':id' => $id, ':skypeid' => $skypeid));
    }


    /**
     * Returns supported query parameter types
     * @return int bitmask of accepted SQL_PARAMS_*
     */
    protected abstract function allowed_param_types();

    public abstract function get_records_sql($sql, array $params=null, $limitfrom=0, $limitnum=0);

      /**
     * Returns the SQL WHERE conditions.
     * @param string $table The table name that these conditions will be validated against.
     * @param array $conditions The conditions to build the where clause. (must not contain numeric indexes)
     * @throws dml_exception
     * @return array An array list containing sql 'where' part and 'params'.
     */
    protected function where_clause($table, array $conditions=null) 
    {
        // We accept nulls in conditions
        $conditions = is_null($conditions) ? array() : $conditions;

        $allowed_types = $this->allowed_param_types();
        if (empty($conditions)) {
            return array('', array());
        }
        $where = array();
        $params = array();

        foreach ($conditions as $key=>$value) {
            if (is_int($key)) {
                throw new dml_exception('invalidnumkey');
            }
            if (is_null($value)) {
                $where[] = "$key IS NULL";
            } else {
                if ($allowed_types & SQL_PARAMS_NAMED) {
                    // Need to verify key names because they can contain, originally,
                    // spaces and other forbidden chars when using sql_xxx() functions and friends.
                    $normkey = trim(preg_replace('/[^a-zA-Z0-9_-]/', '_', $key), '-_');
                    if ($normkey !== $key) {
                        debugging('Invalid key found in the conditions array.');
                    }
                    $where[] = "$key = :$normkey";
                    $params[$normkey] = $value;
                } else {
                    $where[] = "$key = ?";
                    $params[] = $value;
                }
            }
        }
        $where = implode(" AND ", $where);
        return array($where, $params);
    }

    public function get_record_sql($sql, array $params=null, $strictness=IGNORE_MISSING) 
    {
        $strictness = (int)$strictness; // we support true/false for BC reasons too
        if ($strictness == IGNORE_MULTIPLE) 
        {
            $count = 1;
        } 
        else 
        {
            $count = 0;
        }

        if (!$records = $this->get_records_sql($sql, $params, 0, $count)) 
        {
            return false;
        }

        $return = reset($records);
        return $return;
    }

    public function get_record($table, array $conditions, $fields='*', $strictness=IGNORE_MISSING) {
        list($select, $params) = $this->where_clause($table, $conditions);
    
        return $this->get_record_select($table, $select, $params, $fields, $strictness);
    }

    public function get_record_select($table, $select, array $params=null, $fields='*', $strictness=IGNORE_MISSING) 
    {
        if ($select) {
            $select = "WHERE $select";
        }

        return $this->get_record_sql("SELECT $fields FROM " . $table . " $select", $params, $strictness);
 
    }
}

?>